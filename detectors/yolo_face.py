# detectors/yolo_face.py

# Импорт библиотеки ultralytics, которая предоставляет интерфейс к моделям YOLO.
# Модуль YOLO из ultralytics используется для загрузки и работы с моделью.
from ultralytics import YOLO

# Импорт библиотеки OpenCV (cv2) для работы с изображениями.
# В данном модуле она может быть не напрямую использована в логике,
# но OpenCV часто используется для загрузки/обработки изображений,
# которые затем передаются в YOLO.
import cv2

# Импорт стандартной библиотеки logging.
# Она используется для вывода сообщений о состоянии программы (отладка, ошибки).
import logging

# --- Глобальные переменные модуля ---

# Переменная для хранения загруженной модели YOLO.
# Это позволяет загрузить модель один раз при старте программы
# и использовать её многократно, что эффективнее, чем загружать каждый раз.
# Изначально она равна None, так как модель ещё не загружена.
_model = None

# --- Функции модуля ---

def load_yolo_model(model_path: str) -> YOLO:
    """
     Загружает предобученную модель YOLOv8n-face из указанного пути.

     Эта функция отвечает за инициализацию модели YOLO.
     Она используется один раз в начале работы программы или если модель была сброшена.

     Args:
         model_path (str): Путь к файлу модели (например, "yolov8n-face.pt").

     Returns:
         YOLO: Объект модели YOLO, готовый к использованию для детекции.

     Raises:
         FileNotFoundError: Если файл модели не найден по указанному пути.
         Exception: Для любых других ошибок, возникающих при загрузке модели.
     """
    try:
        # Пытаемся загрузить модель с помощью конструктора YOLO(model_path).
        # Библиотека ultralytics автоматически скачает модель, если она не найдена локально.
        model = YOLO(model_path)
        logging.info(f"Модель YOLO загружена из: {model_path}")
        return model
    except FileNotFoundError:
        # Если файл модели не найден, выбрасываем исключение.
        # Это важная ошибка, так как без модели модуль не может работать.
        error_msg = f"Файл модели YOLO не найден по пути: {model_path}"
        logging.error(error_msg)
        raise FileNotFoundError(error_msg)
    except Exception as e:
        # Обработка любых других исключений, которые могут возникнуть при загрузке.
        error_msg = f"Ошибка при загрузке модели YOLO из {model_path}: {e}"
        logging.error(error_msg)
        raise # Переподнимаем исключение, чтобы вызывающий код мог его обработать


def get_model() -> YOLO:
    """
     Возвращает загруженную модель YOLO.

     Эта функция реализует паттерн "ленивая инициализация".
     Модель загружается только при первом вызове get_model() с использованием пути,
     заданного в config.yaml. Последующие вызовы возвращают уже загруженный объект.

     Returns:
         YOLO: Объект модели YOLO, готовый к использованию для детекции.
     """
    global _model # Объявляем, что мы будем использовать глобальную переменную _model.
    if _model is None:
        # Если _model еще не загружена (равна None),
        # мы получаем путь к модели из config.yaml.
        # Пока что мы "жестко" пропишем путь, как в config.yaml.
        # В дальнейшем main.py или другой модуль будет передавать путь сюда.
        # Пока оставим заглушку - в реальном коде main.py передаст путь.
        # model_path = config.detection.model_path # <-- Так будет в реальности, когда config.yaml будет подключен.
        model_path = "yolov8n-face.pt" # Заглушка для примера
        _model = load_yolo_model(model_path)
    return _model


def detect_faces(image, model_path: str = "yolov8n-face.pt"):
    """
     Обнаруживает лица на изображении с помощью предобученной модели YOLOv8n-face.

     Эта функция является основной для детекции. Она принимает изображение,
     загружает (или использует уже загруженную) модель и возвращает координаты
     обнаруженных лиц.

     Args:
         image: Изображение, на котором нужно найти лица.
                Ожидается, что это будет массив NumPy (например, как результат cv2.imread или cap.read()).
         model_path (str): Путь к файлу модели YOLO. По умолчанию "yolov8n-face.pt".

     Returns:
         list: Список словарей, где каждый словарь содержит информацию об одном обнаруженном лице.
               Пример элемента списка:
               {
                   'box': [x1, y1, x2, y2], # Координаты ограничивающего прямоугольника (левый верхний, правый нижний)
                   'confidence': float       # Уверенность модели в детекции (от 0 до 1)
               }
               Возвращает пустой список, если лица не найдены.
     """
    # Получаем модель. Используем get_model() для ленивой инициализации.
    # В реальной системе, чтобы избежать зависимости от config.yaml в этом модуле,
    # путь к модели лучше передавать через get_model(model_path),
    # но для простоты текущей архитектуры, мы сначала загрузим модель по требованию с указанным путем.
    # Однако, чтобы не перезагружать модель каждый раз, будем использовать глобальную переменную _model.
    # Оптимизируем: если _model уже загружена и соответствует model_path, используем её.
    # Для простоты предположим, что model_path всегда один и тот же, или что _model сбрасывается при смене пути.
    # В дальнейшем можно добавить проверку model_path и перезагрузку при необходимости.
    # Пока реализуем простую логику: если _model None, загружаем с model_path.
    if _model is None or _model.predictor.model.ckpt['model'].yaml['nc'] != 1: # Проверка на тип модели (не идеальная, но как базовая)
        # В реальности, если путь может меняться, нужно хранить путь к загруженной модели.
        # Для MVP предположим, что путь не меняется часто, иначе нужен более сложный менеджер моделей.
        model = load_yolo_model(model_path)
    else:
        model = _model # Используем уже загруженную модель

    # Проверка, является ли входное изображение корректным массивом NumPy.
    # Это базовая проверка на ограниченный случай.
    if image is None or not hasattr(image, 'ndim') or image.ndim not in [2, 3]:
        logging.warning("Получено некорректное изображение для детекции лиц.")
        return [] # Возвращаем пустой список, если изображение пустое или неправильного формата.

    # Выполняем предсказание (детекцию) на изображении.
    # results - это объект Results из ultralytics, содержащий информацию о детекциях.
    results = model.predict(image, conf=0.5, save=False) # conf - минимальная уверенность, save - не сохранять изображения

    # Извлекаем bounding boxes (координаты), уверенности и имена классов из результатов.
    # boxes содержит координаты [x1, y1, x2, y2] для каждого обнаруженного объекта.
    # confs содержит уверенность (confidence score) для каждого объекта.
    boxes = results[0].boxes.xyxy.cpu().numpy() # xyxy - формат [x1, y1, x2, y2]
    confs = results[0].boxes.conf.cpu().numpy() # conf - уверенность
    # names = results[0].names # Словарь {class_id: class_name}, для face это обычно {0: 'face'}

    # Создаем список результатов в удобном формате.
    detections = []
    for box, conf in zip(boxes, confs):
        # Создаем словарь для каждого обнаруженного лица.
        detection_info = {
            'box': [int(coord) for coord in box], # Преобразуем координаты в целые числа
            'confidence': float(conf)             # Уверенность как число с плавающей точкой
        }
        detections.append(detection_info)

    logging.info(f"Найдено {len(detections)} лиц на изображении.")
    return detections # Возвращаем список словарей с информацией о лицах

# --- Модуль как исполняемый скрипт (опционально, для тестирования) ---
# if __name__ == "__main__":
#     # Пример использования модуля для тестирования.
#     # Загружаем тестовое изображение
#     test_image = cv2.imread("path_to_test_image.jpg")
#     if test_image is not None:
#         faces = detect_faces(test_image)
#         print(faces)
#     else:
#         print("Не удалось загрузить тестовое изображение.")