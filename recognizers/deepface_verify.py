# recognizers/deepface_verify.py

# Импорт основной функции из библиотеки DeepFace.
# verify() используется для верификации двух изображений.
# represent() используется для извлечения вектора (embedding) из одного изображения.
# В нашем случае нужна именно represent().
from deepface import DeepFace

# Импорт стандартной библиотеки logging.
# Она используется для вывода сообщений о состоянии программы (отладка, ошибки).
import logging

# --- Глобальные переменные модуля (опционально, для кэширования модели) ---

# DeepFace может кэшировать загруженные модели автоматически, но
# для некоторых сценариев можно управлять этим вручную.
# Для простоты MVP, будем полагаться на внутреннее кэширование DeepFace.

# --- Функции модуля ---

def extract_face_embedding(face_image, model_name: str = "ArcFace", enforce_detection: bool = False):
    """
     Извлекает "вектор" (embedding) лица из изображения с помощью DeepFace.

     Эта функция принимает изображение *лица* (обычно кадр, вырезанный YOLO)
     и возвращает числовой вектор, представляющий уникальные черты этого лица.
     Этот вектор будет использоваться для сравнения с другими векторами из базы данных.

     Args:
         face_image: Изображение лица. Ожидается, что это будет массив NumPy (например, как результат cv2.imread или срез из кадра камеры).
                     Изображение должно содержать *одно* лицо.
         model_name (str): Имя модели, используемой для извлечения вектора.
                          Возможные значения: "VGG-Face", "Facenet", "Facenet512", "OpenFace", "DeepFace", "DeepID", "ArcFace", "Dlib".
                          По умолчанию "ArcFace".
         enforce_detection (bool): Если True, DeepFace выдаст ошибку, если не сможет обнаружить лицо.
                                   Если False, DeepFace будет пытаться обработать изображение, даже если лицо не найдено явно.
                                   Для нашего случая, когда мы уверены, что подаем изображение *лица*, можно установить False,
                                   чтобы избежать лишней работы по детекции внутри DeepFace.
                                   По умолчанию False.

     Returns:
         list or None: Вектор (embedding) лица в виде списка чисел (обычно длиной 128 или 512, в зависимости от модели),
                       или None, если вектор не удалось извлечь (например, лицо не обнаружено при enforce_detection=True,
                       или изображение пустое/некорректное).

     Raises:
         ValueError: Если модель с указанным именем не найдена.
         Exception: Для любых других ошибок, возникающих при работе DeepFace.
     """
    # Проверка, является ли входное изображение корректным массивом NumPy.
    # Это базовая проверка на ограниченный случай.
    if face_image is None or not hasattr(face_image, 'ndim') or face_image.ndim not in [2, 3]:
        logging.warning("Получено некорректное изображение для извлечения вектора лица.")
        return None # Возвращаем None, если изображение пустое или неправильного формата.

    try:
        # Вызов DeepFace.represent() для извлечения вектора.
        # img_path: можно передать как массив NumPy.
        # model_name: модель, которую нужно использовать.
        # enforce_detection: см. объяснение в аргументах функции.
        # normalization: обычно вектора нормализуются, но default поведение DeepFace зависит от модели.
        #                Мы можем явно указать normalize=True, если это важно для последующего сравнения.
        #                Для большинства моделей DeepFace делает это автоматически.
        embedding_objs = DeepFace.represent(
            img_path=face_image,
            model_name=model_name,
            enforce_detection=enforce_detection,
            detector_backend='skip', # Так как мы уже обнаружили лицо с помощью YOLO, мы можем "пропустить" детектор DeepFace.
                                     # Это ускорит процесс. 'skip' - это один из способов сказать DeepFace не искать лицо снова.
                                     # Альтернатива - указать конкретный бэкенд ('opencv', 'mtcnn' и т.д.), но 'skip' наиболее эффективен в нашем случае.
            align=False # Также можно отключить выравнивание, так как YOLO уже дал нам изображение лица.
                        # Это может немного ускорить процесс.
        )

        # DeepFace.represent возвращает список словарей, даже если на изображении одно лицо.
        # Каждый словарь содержит 'embedding' и другие поля (bbox, facial_area).
        # Так как мы уверены, что подаем изображение *одного* лица (вырезанное YOLO),
        # нас интересует только первый элемент списка.
        if embedding_objs:
            # Извлекаем сам вектор (embedding) из первого объекта.
            embedding_vector = embedding_objs[0]["embedding"]
            logging.info(f"Вектор лица успешно извлечен с помощью модели '{model_name}'. Длина вектора: {len(embedding_vector)}")
            return embedding_vector
        else:
            # Если список пуст, значит, лицо не было обнаружено или обработано (может случиться, если enforce_detection=True и лицо "плохое").
            logging.warning(f"DeepFace не смог извлечь вектор для изображения с помощью модели '{model_name}'.")
            return None

    except ValueError as e:
        # Обработка ошибки, связанной с неверным именем модели.
        error_msg = f"Неверное имя модели для DeepFace: {model_name}. Ошибка: {e}"
        logging.error(error_msg)
        raise ValueError(error_msg) # Перебрасываем исключение, чтобы вызывающий код знал об ошибке.
    except Exception as e:
        # Обработка любых других исключений, которые могут возникнуть при работе DeepFace.
        error_msg = f"Ошибка при извлечении вектора лица с помощью модели '{model_name}': {e}"
        logging.error(error_msg)
        # В зависимости от требований, можно либо выбросить исключение, либо вернуть None.
        # Вернем None, чтобы вызывающая сторона могла обработать ситуацию.
        # Если ошибка критическая, вызывающий код может решить выбросить исключение самостоятельно.
        return None

# --- Модуль как исполняемый скрипт (опционально, для тестирования) ---
# if __name__ == "__main__":
#     # Пример использования модуля для тестирования.
#     import cv2
#     test_face_image = cv2.imread("path_to_cropped_face.jpg")
#     if test_face_image is not None:
#         embedding = extract_face_embedding(test_face_image)
#         print(f"Длина вектора: {len(embedding) if embedding else 'N/A'}")
#     else:
#         print("Не удалось загрузить тестовое изображение лица.")